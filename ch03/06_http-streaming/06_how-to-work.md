# 06_HTTP-STREAMING

개발 환경 설정 및 MCP 학습 과정 기록

이 문서는 `ch03/06_http-streaming` 예제의 동작 원리에 대해 나눈 질문과 답변을 기록한 것입니다.

---

## HTTP 스트리밍과 비동기 제너레이터

### Q: `async def` 함수 안에서 `await`을 사용하는데, `yield`는 보통 generator로 사용하는데, 여기서는 두 가지 다 사용하네요. `yield`는 값을 호출한 곳에 리턴(돌려주고) 기다리고 있는거죠. `await`은 해당 부분에서 값을 비동기로 기다리는 것이고?

**A:** 네, 완벽하게 이해하셨습니다! **그 두 가지 개념의 조합이 바로 "비동기 제너레이터(Asynchronous Generator)"의 핵심입니다.**

사용자님의 설명을 조금 더 다듬어서, 각 키워드의 역할을 명확히 해보겠습니다.

#### 각 키워드의 정확한 역할:

**`async def` (비동기 함수 선언)**
-   이 함수는 평범한 함수가 아니라, **"잠시 멈추고 다른 일을 하다가 돌아올 수 있는"** 능력을 가진 특별한 함수임을 선언합니다.
-   이 함수를 호출하면, 코드가 바로 실행되는 것이 아니라 **"코루틴(coroutine)"** 이라는 일종의 "실행 계획표" 객체가 반환됩니다.

**`yield` (값을 생성하고 멈춤)**
-   **"이 값을 호출한 쪽으로 일단 던져주고(yield), 바로 이 자리에서 실행을 잠시 멈춘다."**
-   호출한 쪽에서 다음 값을 요청할 때까지 현재 함수의 모든 상태(지역 변수 등)를 그대로 유지한 채 기다립니다.
-   사용자님께서 "값을 호출한 곳에 리턴하고 기다리고 있는거죠"라고 하신 부분이 바로 이것입니다. 정확합니다.

**`await` (다른 비동기 작업이 끝날 때까지 기다림)**
-   **"이 비동기 작업(`asyncio.sleep(1)`)이 끝날 때까지, 이 함수의 실행을 잠시 멈추고, 제어권을 이벤트 루프(event loop)에게 완전히 넘겨준다."**
-   제어권을 넘겨받은 이벤트 루프는 이 시간에 다른 대기 중인 작업(예: 다른 네트워크 요청 처리)을 처리할 수 있습니다.
-   `asyncio.sleep(1)` 작업이 완료되면, 이벤트 루프는 다시 이 함수의 멈췄던 지점으로 돌아와 다음 코드를 실행합니다.
-   사용자님께서 "해당 부분에서 값을 비동기로 기다리는 것"이라고 하신 부분이 바로 이것입니다. 완벽합니다.

#### `event_stream` 함수의 동작 시나리오:

1.  **호출**: `event_stream("hello")`를 호출하면, 비동기 제너레이터 객체가 생성됩니다.
2.  **첫 번째 `yield`**: 클라이언트가 이 제너레이터의 첫 번째 값을 요청(`for line in ...`)하면, 함수는 `for` 루프에 진입하여 `yield "Processing file 1/3...\n"`를 만납니다.
    -   `"Processing file 1/3...\n"` 값을 클라이언트에게 던져줍니다.
    -   그리고 바로 그 자리에서 실행을 멈추고 대기합니다.
3.  **첫 번째 `await`**: 클라이언트가 다음 값을 요청하면, 멈췄던 부분부터 다시 실행하여 `await asyncio.sleep(1)`을 만납니다.
    -   `event_stream` 함수는 여기서 1초 동안 실행을 멈추고, 제어권을 이벤트 루프에 넘깁니다. **이 1초 동안 서버는 다른 클라이언트의 요청을 처리하는 등 다른 일을 할 수 있습니다.**
4.  **두 번째 `yield`**: 1초가 지나면, 다시 `for` 루프의 처음으로 돌아가 `yield "Processing file 2/3...\n"`을 실행하고 값을 던져준 뒤 다시 멈춥니다.
5.  **반복**: 이 과정이 `for` 루프가 끝날 때까지 반복됩니다.
6.  **마지막 `yield`**: 루프가 끝나면 마지막 `yield f"Here's the file content: {message}\n"`를 실행하고 값을 던져줍니다.
7.  **종료**: 더 이상 `yield`할 값이 없으면 함수는 조용히 종료됩니다.

이처럼 `yield`는 **호출자와의 상호작용**을 위해 실행을 멈추는 것이고, `await`은 **다른 비동기 작업**을 위해 실행을 멈추는 것입니다. 이 둘을 함께 사용하여, 시간 소모적인 작업(I/O) 중에도 서버 전체가 멈추지 않고, 중간 결과들을 실시간으로 클라이언트에게 전달하는 강력한 스트리밍 기능을 구현할 수 있는 것입니다.

사용자님의 이해는 완벽합니다.

---

### Q: `@app.get("/stream")`에서 위 `event_stream()`을 호출하는데, 클라이언트 쪽에 아래와 같은 결과가 출력됩니다: `Processing file 1/3...` 등

**A:** 네, 정확히 그 결과가 나오는 것이 맞습니다! 그 코드가 어떻게 그런 스트리밍 출력을 만들어내는지, 각 부분이 어떤 역할을 하는지 상세히 설명해 드리겠습니다.

#### 서버와 클라이언트의 상호작용 분석:

이 과정은 서버 측의 **`StreamingResponse`**와 클라이언트 측의 **`requests` 라이브러리**가 협력하여 이루어집니다.

**서버 측 (`server.py`)**
1.  **`@app.get("/stream")`**: 클라이언트가 `/stream` 경로로 `GET` 요청을 보내면 `stream` 함수를 실행하라고 FastAPI에 지시합니다.
2.  **`async def stream(message: str = "hello")`**: 이 함수는 클라이언트의 요청을 받습니다.
3.  **`event_stream(message)` 호출**: 가장 중요한 부분입니다. 이 함수는 비동기 제너레이터인 `event_stream`을 호출하지만, **코드를 즉시 실행하지 않습니다.** 대신, 실행 준비가 된 **"비동기 제너레이터 객체"**를 생성합니다. 이것은 마치 "이제부터 스트리밍을 시작할 준비가 됐어!"라고 적힌 설명서와 같습니다.
4.  **`return StreamingResponse(...)`**: FastAPI는 이 특별한 응답 객체를 클라이언트에게 보냅니다.
    -   **`StreamingResponse`**의 역할: "이 응답은 한 번에 끝나지 않고, 내가 가지고 있는 이 제너레이터(`event_stream` 객체)가 값을 생성할 때마다 계속해서 조각조각 보낼 거야"라고 클라이언트에게 알려줍니다.
    -   **`media_type="text/event-stream"`**: HTTP 헤더를 설정하여, 클라이언트에게 "이것은 평범한 텍스트가 아니라, 서버가 보내주는 이벤트 스트림(SSE)이야"라고 알려주는 역할을 합니다.

**클라이언트 측 (`client.py`)**
1.  **`requests.get(url, stream=True, ...)`**: 클라이언트는 `/stream`으로 요청을 보냅니다. 가장 중요한 부분은 **`stream=True`** 입니다. 이 옵션은 `requests` 라이브러리에게 "서버의 응답을 한 번에 다 받지 말고, 도착하는 대로 실시간으로 처리할게"라고 지시합니다.
2.  **`for line in r.iter_lines():`**: 이 `for` 루프는 서버로부터 데이터 조각이 도착할 때까지 기다립니다. 서버의 `event_stream` 함수에서 `yield`를 통해 첫 번째 값(`"Processing file 1/3...\n"`)이 생성되어 클라이언트로 전송됩니다. 클라이언트의 `for` 루프는 이 값을 받아서 `line` 변수에 할당하고 루프의 본문을 실행합니다.
3.  **`print(decoded_line)`**: 받은 데이터 조각을 터미널에 출력합니다. (`Processing file 1/3...`)
4.  **루프 반복**: 클라이언트의 `for` 루프는 다음 데이터 조각을 기다립니다. 서버에서는 1초간의 `await asyncio.sleep(1)`이 끝나고, `event_stream`이 다음 `yield`를 통해 두 번째 값을 보냅니다. 이 과정이 `event_stream` 제너레이터가 모든 값을 생성하고 끝날 때까지 반복됩니다.

#### 결론:

-   **서버**는 `StreamingResponse`와 `yield`를 사용해 데이터를 조각내어 보낼 준비를 합니다.
-   **클라이언트**는 `stream=True`와 `for` 루프를 사용해 서버가 보내주는 데이터 조각을 실시간으로 받아서 처리합니다.

이 둘의 완벽한 협력 덕분에, 우리는 1초 간격으로 서버의 처리 과정을 실시간으로 터미널에서 지켜볼 수 있는 것입니다. 이것이 바로 HTTP 스트리밍의 핵심 원리입니다. 